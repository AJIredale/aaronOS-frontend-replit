ğŸš€ I am building **AaronOS**, an autonomous, modular AI operating system. I want you to generate a production-quality **frontend UI** using **React + TailwindCSS + shadcn/ui**, designed to interface cleanly with my existing backend (Node.js + Express + Redis + Docker). This UI will act as the main command interface for interacting with my internal agent, **Aaron** â€” a GPT-based AI automation system.

### ğŸ¯ Key Objectives:
- Wrap the **Aaron AI agent** in a sleek, minimal, responsive UI
- Display AI conversation threads with sharp UX
- Include modules for viewing active memory (RAM), pinned context, and flushed memory shards
- Integrate task tracking and command input
- Merge seamlessly with my current AaronOS backend

---

## ğŸ”§ Backend API Overview (already built):

- `GET /api/agent/status` â€” returns current agent state (idle, thinking, executing)
- `POST /api/agent/message` â€” send message to the AI, returns response
- `GET /api/context/active` â€” returns current working memory (~15k tokens max)
- `GET /api/context/shard/:project` â€” returns cold memory (flushed data) per project
- `POST /api/flush/trigger` â€” flushes resolved context
- `GET /api/tasks` â€” returns current tasks with status (`planned`, `in_progress`, `resolved`)
- WebSocket (via Socket.IO) â€” for live task updates, chat output, and streaming responses

---

## ğŸ§  FlushCore Memory System (important!)

- RAM = active short-term memory (live, unresolved tasks or context)
- Pinned = locked tasks/goals the user wants visible at all times
- Flushed = compressed memory (stored by project, retrieved via shard ID)
- UI must allow toggling between these memory states

---

## ğŸ“¦ UI Component Requirements:

### âœ… 1. Chat Interface (`ChatPanel`)
- Show threaded conversation with **Aaron**
- Highlight system messages (e.g. "Task flushed", "Context switched")
- Streaming output via WebSocket
- Markdown support for AI messages
- Code blocks shown in a monospaced box
- Auto-scroll on new message

### âœ… 2. Command Bar (`CommandBar`)
- Slash-style commands (e.g. `/flush`, `/pin`, `/switch project`)
- Autocomplete suggestions
- Press `Enter` to trigger POST `/api/agent/message`

### âœ… 3. Memory Dashboard (`MemoryPanel`)
- Tabs: `Active RAM`, `Pinned`, `Flushed`
- Allow restoring flushed memory to RAM
- Show compressed memory summaries
- Highlight status (`resolved`, `in_progress`, `pinned`)

### âœ… 4. Task Viewer (`TaskPanel`)
- List current tasks with tags (priority, state, time)
- Sort by active, blocked, resolved
- Show timestamps
- Allow pin/unpin per task

### âœ… 5. Agent Status (`AgentStatus`)
- Display current status (Idle / Thinking / Executing)
- Show system load (optional), last response time
- Status indicator via color (ğŸŸ¢ / ğŸŸ¡ / ğŸ”´)

---

## ğŸ§ª Developer Requirements:

- Stack: **React + TailwindCSS + shadcn/ui + TypeScript**
- Clean folder structure (`components/`, `hooks/`, `lib/`, `pages/`)
- State: use Zustand or React Context (your choice, but must be clean)
- Live updates: connect to backend Socket.IO endpoint
- Axios for API requests
- Framer Motion for subtle animations (transitions, fades, etc.)
- Mobile responsive design (chat input bar floats bottom of viewport)

---

## ğŸ“ Ideal Folder Structure:

/src
/components
ChatPanel.tsx
CommandBar.tsx
MemoryPanel.tsx
TaskPanel.tsx
AgentStatus.tsx
/hooks
useSocket.ts
useAgentState.ts
/pages
index.tsx
/lib
api.ts // Axios instance
memoryUtils.ts // Flush/restore helpers
tailwind.config.ts
App.tsx

yaml
Copy

---

## ğŸ§™â€â™‚ï¸ Bonus Features (optional if time allows):

- Memory Heatmap visual (blocks for RAM / Pinned / Flushed per project)
- Notification tray for system events
- Export memory as `.json` or `.md` file
- Floating **Aaron** Assistant panel (like a mini assistant in the corner)
- Dark Mode toggle

---

## ğŸ“£ What NOT to Do:

- Donâ€™t build the backend â€” it already exists
- Donâ€™t store chat state locally â€” itâ€™s all backend managed
- Donâ€™t assume OpenAI streaming, we use backend relay via Socket.IO
- Donâ€™t use huge component libraries like Material UI

---

## ğŸ End Goal:

A sleek, fast, context-aware frontend dashboard to manage AI agents, memory, and workflows visually. I want this to **feel like Notion x Linear x Replit**, with the **soul of a command-line tool**, and the **intelligence of an operating system**.

**AaronOS** is not just a chatbot â€” itâ€™s an AI-powered operating layer for task execution, context retention, and logic chaining.

Make this frontend so smooth I forget Iâ€™m not typing to a real assistant.

